---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# 6. Συναρτήσεις

+++ {"tags": []}

## Τι είναι οι συναρτήσεις
Οι συναρτήσεις (functions) είναι μια επαναχρησιμοποιούμενη ομάδα εντολών η οποία εκτελείται μόνο όταν κληθεί. Στο σύνολο αυτό των εντολών δίνεται ένα όνομα με το οποίο είναι αναγνωρίσιμο. Μπορούμε να καλέσουμε μια συνάρτηση όσες φορές θέλουμε στο πρόγραμμά μας.Μια συνάρτηση μπορεί να δέχεται παραμέτρους δηλαδή δεδομένα εισόδου και να παράγει αποτελέσματα δηλαδή δεδομένα εξόδου. Με την χρήση συναρτήσεων επιτυγχάνεται, αρθρωτή δομή (modularity), λιγότερη επανάληψη κώδικα (code reusing), ευκολότερη αποσφαλμάτωση, αναγνωσιμότητα και ευκολία διόρθωσης. Πέρα από τις συναρτήσεις που μπορεί να συντάξει ο προγραμματιστής (user-defined functions), η Python προσφέρει ήδη έτοιμες συναρτήσεις (built-in functions). 

Η βασική ιδέα με την χρήση των συναρτήσεων είναι να απομονώσουμε ένα κομμάτι κώδικα που επιτελεί πολύ συγκεκριμένη λειτουργία και να το καλούμε όταν μας είναι αναγκαίο. Για παράδειγμα αν σε ένα πρόγραμμα απαιτείται ο τακτικός υπολογισμός του Πυθαγόρειου θεωρήματος, αντί να επιλύουμε κάθε φορά την αντιστοίχη εξίσωση αρκεί να δημιουργήσουμε μια συνάρτηση που θα δέχεται σαν παραμέτρους τα μήκη δυο καθέτων πλευρών του ορθογωνίου τριγώνου και θα επιστρέφει το τετράγωνο της υποτείνουσας. Οπότε κάθε φορά που θα χρειάζεται η επίλυση του Πυθαγόρειου θεωρήματος αρκεί η κλήση της συνάρτησης και ο ορισμός των αντίστοιχων παραμέτρων σε αυτήν. Αν διαπιστώσουμε ότι ο μαθηματικός τύπος που έχουμε χρησιμοποιήσει είναι λάθος τότε αρκεί η διόρθωση μόνο σε ένα σημείο του κώδικα, σε αυτό της συνάρτησης. Αν αντιθέτως στο πρόγραμμά μας αντι για συνάρτηση είχαμε χρησιμοποιήσει ξεχωριστά την επίλυση της ίδιας εξίσωσης τότε θα έπρεπε να εντοπίσουμε και να διορθώσουμε όλα αυτά τα επιμέρους σημεία του κώδικα.

+++ {"jp-MarkdownHeadingCollapsed": true, "tags": []}

## Τρόπος σύνταξης και κλήσης

Ο ορισμός μιας συνάρτησης στην Python ξεκινάει με την δεσμευμένη λέξη `_def_`, στην συνέχει δίνεται ένα όνομα για την συνάρτηση, ακολουθούν οι παρενθέσεις (εντός τους μπορεί να ορίζονται και οι παράμετροι) και ακολουθεί η άνω/κάτω τελεία (colon). Στην συνέχει ακολουθεί (με εσοχές 4 space) μια σύντομη περιγραφή (docstrings) για το τι κάνει η συνάρτηση (προαιρετικά), και το σχετικό κομμάτι εντολών. Μπορεί κατά την ολοκλήρωση, επίσης προαιρετικά, η συνάρτηση να επιστρέφει κάποια τιμή μέσω της λέξης-κλειδί `_return_`. Σε κάθε περίπτωση όταν το _return_ καλείται μέσα στην συνάρτηση τότε αυτή σταματάει την εκτέλεση του κώδικα που περιέχει και επιστρέφει στο σημείο απ' όπου καλέστηκε.
Η ονοματολογία των συναρτήσεων υπακούει στους κανόνες ονοματολογίας των μεταβλητών και συνήθως περιγράφουν τι κάνουν. 
Προηγείται ο ορισμός μια συνάρτησης και μετά η κλήση της. Γι' αυτό τον λόγο οι συναρτήσεις δηλώνονται πρώτα σε ένα πρόγραμμα και μετά ακολουθεί το κυρίως σώμα του κώδικα μέσα στον οποίο μπορούμε να τις καλέσουμε.
Παρακάτω δίνεται μια απλουστευτική μορφή της σύνταξης μιας συνάρτησης.

```{code-cell} ipython3
def function_name(parameters):
    """docstring"""
    statement(s)
```

Ας δούμε ένα πιο πρακτικό παράδειγμα. Παρακάτω ακολουθεί η σύναξη μιας απλής συνάρτηση όπου δεν ορίζονται κάποιοι παράμετροι ούτε επιστρέφεται κάποια τιμή.

```{code-cell} ipython3
def sayHello():
    '''Μια συνάρτηση που χαιρετά τον κόσμο.'''
    print("Hello World!")
```

Στην συνέχεια ακολουθεί η κλήση της όπου ουσιαστικά εκτελείται το σώμα της συνάρτησης. Η κλήση της γίνεται ορίζοντας το όνομά της και στην συνέχεια ακολουθούν παρενθέσεις: 

```{code-cell} ipython3
sayHello()
```

## Συνάρτηση με παραμέτρους

Σε αρκετές περιπτώσεις μια συνάρτηση μπορεί να περιλαμβάνει δεδομένα εισόδου (`παράμετροι`) τα οποιά είναι χρήσιμα κατά την εκτέλεση του κώδικά της. Οι παράμετροι αυτοί ορίζονται κατά την σύνταξη της συνάρτησης, μέσα στις παρενθέσεις που ακολουθούν το όνομα της. Κατά την κλήση οι παράμετροι αυτοί λαμβάνουν τιμές ή μεταβλητές και ονομάζονται `ορίσματα`.

```{code-cell} ipython3
def sayHelloUser(name):
    '''
    Μια συνάρτηση που χαιρετά τον κάποιο.
    Παράμετροι:
        name(str): ένα όνομα
    Επιστρέφει:
        Τίποτα
    
    '''
    print("Hello", name, "!")
```

Στην παραπάνω συνάρτηση με το ονομα `sayHelloUser` ορίσαμε την παράμετρο `name` όπου την χρησιμοποιούμε στην συνέχεια στο κυρίως σώμα της συνάρτησης.

Στην συνέχεια καλούμε την συνάρτηση δίνοντας σαν όρισμα (τιμή στην παράμετρο) την συμβολοσειρά "Κώστας".
Έτσι η παράμετρος `name` δέχεται όρισμα την τιμή "Κώστας".

```{code-cell} ipython3
sayHelloUser("Κώστας")
```

Αντίστοιχα μπορούμε να δώσουμε διαφορετική τιμή στο όρισμα ακόμα και μέσω μίας μεταβλητής:

```{code-cell} ipython3
onoma="Χρήστος"
sayHelloUser(onoma)
```

Το παραπάνω μπορεί να γραφτεί και πιο ρητά κάτα πέρασμα του ορίσματος στην παράμετρο.

```{code-cell} ipython3
onoma="Ελένη"
sayHelloUser(name=onoma)
```

Η χρησιμότητα του docstring που αναγράφουμε σε μια συνάρτηση φαίνεται αν καλέσουμε την βοήθεια της Python αναφορικά με την συγκεκριμένη συνάρτηση. Με αυτόν τον τρόπο λαμβάνουμε πληροφορίες για την λειτουργία της χωρίς να χρειαστεί να ανατρέξουμε στην σύνταξή της.

```{code-cell} ipython3
help(sayHelloUser)
```

Εναλλακτικά μπορούμε να χρησιμοποιήσουμε το `__doc__` attribute της συνάρτησης.

```{code-cell} ipython3
print(sayHelloUser.__doc__)
```

Παρακάτω ορίζεται μια συνάρτηση με δύο παραμέτρους:

```{code-cell} ipython3
def add(num1, num2) :
    """Add two numbers"""
    num3 = num1 + num2
    print("Το άθροισμα των αριθμών " + str(num1) + " και " +str(num2) + "  είναι " + str(num3))
```

Την καλούμε με τα σχετικά ορίσματα:

```{code-cell} ipython3
add(10,7)

# αντί τιμών πέρασμα μεταβλητών ως ορίσματα στην συνάρτηση
a=2
b=5

add(a, b)

# ή μεικτός τρόπος
add(9, a)
```

### Ορίσματα θέσης (Positional arguments)

Όταν συντάσσεται μια συνάρτηση με πολλές παραμέτρους κατά την κλήση της πρέπει να ορίσουμε και αντίστοιχα ορίσματα.
Το πέρασμα αυτών των ορισμάτων γίνεται είτε α) κατα θέση (`positional arguments`) είτε β) με βάση την λέξη κλειδί (`keyword arguments`).
Τα _ορίσματα θέσης_ ορίζονται κατά σειρά με βάση τις αντίστοιχες παραμέτρους που έχουν οριστεί κατά την σύνταξη της συνάρτησης. Το παρακάτω παράδειγμα είναι πιο κατανοητό:

```{code-cell} ipython3
def car(style, color):
    '''Information about a car'''
    print("Ο τύπους του αυτοκινήτου είναι:", style)
    print("και έχει χρώματα:", color)

    
car("Sedan", "μαύρο")
    
```

Στην παραπάνω περίπτωση ορίσαμε μια function που εκτυπώνει το _style_ και το _color_ ενός αυτοκινήτου.
Κατά την κλήση της περνάμε τα ορίσματα κατά θέση. Δηλαδή στην πρώτη θέση κατά την σύνταξη έχουμε την παράμετρο _style_ που παίρνει το όρισμα _"Sedan"_ και στην δεύτερη θέση έχουμε την παράμετρο _color_ που παίρνει το όρισμα _"μαύρο"_.
Με τα ορίσματα θέσης πρέπει να είμαστε ακριβής στις τιμές που περνάμε σε κάθε γιατί αλλιώς μπορεί να έχουμε απροσδιόριστα αποτελέσματα. Δείτε το παρακάτω παράδειγμα:

```{code-cell} ipython3
car("κόκκινo", "SUV")
```

### Ορίσματα με βάση την λέξη-κλειδί (keyword arguments)

Τα ορίσματα κλειδιά είναι πιο ευέλικτα καθότι περνάμε ένα ζεύγος κλειδιού-τιμής. Έτσι ορίζουμε ρητά και ονομαστικά σε κάθε παράμετρο τι τιμή θα λάβει. Σε αυτή την περίπτωση δεν παίζει ρόλο η σειρά που περνάμε τιμές αλλά η αντιστοιχεία ονομασία παραμέτρου με τιμή ορίσματος. Για αυτόν τον λόγο χρειάζεται προσοχή κατά την αντιστοιχία να χρησιμοποοιούμε τα σωστλα ονόματα παραμέτρων όπως διατυπώνονται στην σύνταξη της συνάρτησης. Ας δούμε το παραπάνω παράδειγμα με ορίσματα κλειδιά:

```{code-cell} ipython3
car(color="κόκκινo", style="SUV")
car(style="SUV",color="κόκκινo", )
```

### Προκαθορισμένη τιμή παραμέτρου

Μια παράμετρο μπορεί να έχει μια προκαθορισμένη τιμή κατά την σύνταξη της συνάρτησης. Αν κατά την κλήση της συνάρτησης δώσουμε τιμή σε αυτήν την παράμετρο τότε αγνοείται η προκαθορισμένη τιμή. Όμως αν δεν δώσουμε τιμή τότε η παράμετρος κρατάει την προκαθορισμένη τιμή. Έτσι σε αρκετές περιπτώσεις όταν καλούμε μια συνάρτηση μπορεί οι προκαθορισμένες τιμές να αρκούν και να μην χρειάζεται να ορίσουμε τιμές στην αντίστοιχη παράμετρο. Ας δούμε το παρακάτω παράδειγμα:

```{code-cell} ipython3
def car(style, color, wheels="τέσσερις"):
    '''Information about a car'''
    print("Ο τύπους του αυτοκινήτου είναι:", style)
    print("Έχει χρώμα", color, "και έχει", wheels, "τροχούς")
```

```{code-cell} ipython3
car(color="μπλέ", style="SUV")
```

Στο παραπάνω παράδειγμα δεν χρειάζεται να ορίσουμε τιμή για την παράμετρο _wheels_ γιατί μας αρκεί η προκαθορισμένη, μιας και όλα σχεδόν τα επιβατικά έχουν τέσσερις τροχούς. Αντίστοιχα μπορεί να οριστούν και προκαθορισμένες τιμές και για τις άλλες παραμέτρους.

+++

Βέβαια μπορούμε να αγνοήσουμε την προκαθορισμένη τιμή και να περάσουμε την αναγκαία κατά περίπτωση. π.χ. εδώ αγνοούμε την προκαθορισμένη τιμή για την παράμετρο _wheels_ (τέσσερις) και ορίζουμε τιμή έξι.

```{code-cell} ipython3
car(color="μπλέ", wheels="έξι",style="SUV")
```

Εναλλακτικά το προηγούμενο μπορεί να συνταχθεί με ορίσματα θέσης:
    

```{code-cell} ipython3
car("μπλέ", "SUV", "έξι")
```

## Επιστροφή τιμής από μία συνάρτηση

Στα προηγούμενα παραδείγματα περιγράφεται η σύνταξη συναρτήσεων χωρίς να επιστρέφονται τιμές από αυτές. Στην συνέχεια θα δούμε πως μια συνάρτηση μπορεί να επιστρέψει τιμές μέσω της λέξης-κλειδιού `return`. Ας επεκτείνουμε το προηγούμενο παράδειγμα με την συνάρτηση που προσθέτει δύο αριθμούς. Η συνάρτηση αυτή μέχρι τώρα απλά δημιουργεί μια νέα μεταβλητή με το άθροισμα και στην συνέχεια εκτυπώνει ένα μήνυμα. Δεν επιστρέφει τίποτα. Αν δοκιμάσουμε να δούμε τι τύπο δεδομένων επιστρέφει θα δούμε ότι είναι `NoneType`.

```{code-cell} ipython3
type(add(1, 2))
```

Ας τροποποιήσουμε την συνάρτηση ώστε να επιστρέφει μία τιμή. Θα δώσουμε νέο όνομα στην συνάρτηση, addV2

```{code-cell} ipython3
def addV2(num1, num2) :
    """Add two numbers"""
    num3 = num1 + num2
    return(num3)
```

 Πλέον η συνάρτηση επιστρέφει το άθροισμα των τιμών που είναι ακέραιος τύπος δεδομένων. Το αποτέλεσμα της συνάρτησης που επιστρέφει το `return` μπορούμε να το προσαρτήσουμε σε μια μεταβλητή.

```{code-cell} ipython3
result=addV2(5,3)
```

Η συνάρτηση συνεχίζει να εκτυπώνει το μήνυμα που έχει οριστεί κατά την σύνταξη αλλά πλέον επιστρέφει και τιμή:

```{code-cell} ipython3
result
```

Την οποία μπορούμε να χρησιμοποιήσουμε σε άλλες προτάσεις του κώδικα. πχ

```{code-cell} ipython3
print("Το αποτέλεσμα της πράξης είναι:" + str(result))
```

ή μπορούμε να την καλέσουμε άμεσα:

```{code-cell} ipython3
print("Το αποτέλεσμα της πράξης είναι:" + str(addV2(9,9)))
```

Ο τύπος δεδομένων που επιστρέφει η συνάρτηση είναι ακέραιος (`int`):

```{code-cell} ipython3
type(addV2(1, 2))
```

## Πολλαπλές επιστρεφόμενες τιμές

Σε ορισμένες περιπτώσεις συναρτήσεων μπορεί να απαιτούμε να επιστρέφονται παραπάνω από μία τιμές. Τότε χρησιμοποιούμε μια μέθοδος που λέγεται tuple packing κατά την οποία δημιουργούμε μια πλειάδα με τις αναγκαίες τιμές. Κατά την κλήση της συνάρτησης μπορούμε να προσαρτήσουμε το αποτέλεσμα που επιστρέφει σε αντίστοιχο πλήθος μεταβλητών (tuple unpacking).

```{code-cell} ipython3
def addV3(num1, num2) :
    """Add two numbers"""
    num3 = num1 + num2
    return(num3, num3**2) #tuple packing
```

```{code-cell} ipython3
sum, squareofsum = addV3(4, 1) # tuple unpacking
print("Sum:", sum, ", Square of sum:", squareofsum)
```

Μια συνάρτηση μπορεί να επιστρέφει και ένα λεξικό ή μία λίστα.

+++

## Εμβέλεια μεταβλητών

+++

Οι μεταβλήτες στην Python διαχωρίζονται με βάση την εμβέλειά τους (δηλαδή από ποιό σημείο του κώδικα είναι "ορατές"),  σε _τοπικές (local)_ και _καθολικές (global)_. 

**Καθολικές** είναι οι μεταβλητές που ορίζονται στο κυρίως σώμα του κώδικα και δεν εντάσσονται μέσα σε κάποια συνάρτηση. Αυτές είναι προσπελάσιμες από κάθε σημείο του κώδικα ακόμα και μέσα από συναρτήσεις.

**Τοπικές** είναι οι μεταβλητές οι οποίες ορίζονται μέσα σε συναρτήσεις, είναι προσπελάσιμες μόνο μέσα σε αυτές και διαρκούν όσο διαρκεί η εκτέλεση μιας συνάρτησης. Κατά την πολλάπλή κλήση μιας συνάρτησης δημιουργούνται αντίστοιχες τοπικές μεταβλητές που περιγράφονται στην σύνταξή της. Οι παράμετροι μιας συνάρτησης αποτελούν και αυτές τοπικές μεταβλητές. Ας ορίσουμε μια τοπική μεταβλητή. Στην παρακάτω συνάρτηση ορίζεται η τοπική μεταβλητή `text`.

```{code-cell} ipython3
def PrintMyText():      
    text = "Athens"
    print(text)
    
PrintMyText()
```

Αν δοκιμάσουμε να προσπελάσουμε την μεταβλητή `text` εκτός συνάρτησης θα λάβουμε σχετικό σφάλμα:

```{code-cell}
:tags: [raises-exception]
print(text)
```

Όπως προαναφέρθηκε και μια παράμετρος αποτελεί τοπική μεταβλητή:

```

```{code-cell} ipython3
def PrintMyText(p):      
    print(p)

PrintMyText("Βόλος")
```

Αντιθέτως μια καθολική μεταβλητή είναι προσβάσιμη σε μία συνάρτηση.

```{code-cell} ipython3
city="Λάρισα"
def PrintMyText():      
    print("Η τιμή της μεταβλητής city ΕΝΤΟΣ της συνάρτησης", city) # η καθολική μεταβλητή είναι προσβάσιμη μέσα στην συνάρτηση
    
PrintMyText() # γι αύτό και εκτυπώνεται κατά την κλήση

print("Η τιμή της μεταβλητής city ΕΚΤΟΣ συνάρτησης", city)  # και φυσικά είναι διαθέσιμη και εκτός συνάρτησης από οποιοδήποτε σημείο του κώδικα
```

Τι συμβαίνει όμως όταν μια μεταβλητή ορίζεται με την ίδια ονομασία σαν καθολική και τοπική; Δείτε το παρακάτω παράδειγμα:
    

```{code-cell} ipython3
city="Λάρισα"
def PrintMyText(): 
    city="Βόλος" # τοπική μεταβλητή, προτεραιότητα έναντι της καθολικής
    print("Η τιμή της μεταβλητής city ΕΝΤΟΣ της συνάρτησης (τοπική)", city) # εδώ εκτυπώνεται η τοπική μεταβλητή
    
PrintMyText() # θα εκτυπώσει την τοπική

print("Η τιμή της μεταβλητής city ΕΚΤΟΣ συνάρτησης (καθολική)", city)  # θα εκτυπώσει την καθολική
```

Αν θέλουμε να αλλάξουμε την τιμή μιας καθολικής μέσα σε μια συνάρτηση χρησιμοποιούμε την λέξη κλειδί `global` για να αναφερθούμε σε αυτήν.

```{code-cell} ipython3
# Αυτή η συνάρτηση θα τροποποιήσει την καθολική μεταβλητή city
def printCity():
    global city
    city += ', πρωτεύουσα της Ελλάδας'
    print(city)
    
    city = "Βόλος"    
    print(city) 

# Καθολική εμβέλεια
city= "Αθήνα"
printCity()
print(city)
```

## Συναρτήσεις lambda 

Οι συναρτήσεις _lambda_ είναι μικρές ανώνυμες συναρτήσεις που μπορούν να έχουν πολλά ορίσματα αλλά μία έκφραση. Για παράδειγμα:

```{code-cell} ipython3
x = lambda a : a ** 2
x(5)
```

Σε αυτό το παράδειγμα ορίζεται μια συνάρτηση _lambda_ που επιστρέφει το τετράγωνο ενός αριθμού. Στο παρακάτω παράδειγμα μια συνάρτηση _lambda_ υπολογίζει το γινόμενο δύο αριθμών.

```{code-cell} ipython3
x = lambda a,b : a * b
x(2,3)
```

Άλλο παράδειγμα

```{code-cell} ipython3
onomateponymo = lambda onoma, epitheto, birth: f'Ονοματεπώνυμο: {onoma.title()} {epitheto.title()}, Έτος γέννησης: {birth}'
onomateponymo('αριστοτέλης', 'ωνάσης', 1906)
```

Πρακτική εφαρμογή της συνάρτησης _lambda_ όπου χρησιμοποιείται για να φιλτραριστούν οι τιμές μιας λίστας με βάση ένα κριτήριο.

```{code-cell} ipython3
# Program to filter out only the even items from a list
nums = [1, 2, 9, 10, 18, 31, 53, 120]

nums_filtered = list(filter(lambda x: x >= 10 , nums))

print(nums_filtered)
```

Στο παρακάτω παράδειγμα χρησιμοποιείται μια _lambda_ συνάρτηση σε συνδυασμό με την συνάρτηση map που στόχο έχει πολλάπλασιάσει x2 τα στοιχεία μας λίστας.

```{code-cell} ipython3
# Program to double each item in a list using map()

nums = [1, 2, 9, 10, 18, 31, 53, 120]

nums_squared = list(map(lambda x: x * 2 , nums))

print(nums_squared)
```
