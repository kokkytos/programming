#!/usr/bin/env python
# coding: utf-8

# # 5. Έλεγχος ροής εκτέλεσης
# 
# Όλες οι γλώσσες προγραμματισμού απαρτίζονται από μια σειρά από προγραμματιστικές δομές.
# Οι τρεις βασικές δομές ελέγχου ροής προγράμματος είναι 
# η δομή της ακολουθίας εντολών, 
# η δομή της απόφασης και 
# η δομή της επανάληψης.
#  Κάποιες από αυτές αντιστοιχούν σε περισσότερες από μία εντολές {cite}`Manis2015`.
# 
# 
# 
# 
# ## Η λογική boolean
# Για την υλοποίηση των δομών απόφασης χρησιμοποιείται η λογική **boolean** κατά την οποία ελέγχονται μία ή περισσότερες συνθήκες
# και ανάλογα το αποτέλεσμα επιλέγεται ποια ακολουθία εντολών θα εκτελεστεί.
# Το όνομα **boolean** προέρχεται από τον
# Βρετανό Μαθηματικό George Boole, ο οποίος εισήγαγε την ομώνυμη άλγεβρα
# που αφορά σε λογικούς κανόνες συνδυασμού των δύο τιμών True (Αληθής ) και
# False (Ψευδής). Οι τιμές αυτές ονομάζονται λογικές ή Boolean και ο τύπος
# τους στην Python είναι ο bool {cite}`Aggelidakis2015`.

# In[1]:


type(False)


# Μία μεταβλητή μπορεί να δείχνει και σε μία τιμή
# τύπου bool. Για παράδειγμα:

# In[2]:


raining=True
type(raining)


# Οι λογικές μεταβλητές είναι μεταβλητές οι οποίες διέπονται από την δυαδική λογική στην επιστήμη της πληροφορικής (1 και 0) και παίρνουν δύο τιμές *True*
# ή *False*. Ουσιαστικά πρόκεται για συνώνυμα του 1 (True) και 0 (False).

# In[3]:


True+True
42 * True + False


# Ο συνδυασμός των Boolean τιμών γίνεται
# με τη χρήση τριών βασικών λογικών τελεστών:
# **not**, **and** και **or**. Οι τελεστές αυτοί
# συμβολίζουν λογικές πράξεις (όχι, και , ή) και
# βοηθούν στη λήψη αποφάσεων σε ένα
# πρόγραμμα. Η σημαντική τους είναι πολύ παρόμοια με την καθημερινή τους
# σημασία  {cite}`Aggelidakis2015`. 
# Ας υποθέσουμε ότι *A* και *B* είναι δύο μεταβλητές που δείχνουν σε
# Boolean τιμές ή δύο εκφράσεις (ονομάζονται λογικές ή Boolean) που
# αποτιμώνται σε Boolean τιμές. Ο επόμενος πίνακας, ο οποίος ονομάζεται
# πίνακας αληθείας, περιέχει τις τιμές που επιστρέφουν οι τρεις λογικές πράξεις
# για όλους τους συνδυασμούς τιμών των *A* και *B*.
# 
# ```{figure} ../images/nl0W8.jpg
# :name: figure-truthtable
# 
# Πίνακας αληθείας για τους βασικούς λογικούς τελεστές.
# ```
# 
# Η λογική έκφραση not *Α*  είναι αληθής, όταν η*Α*  ψευδής, και ψευδής,
# όταν η *Α*  είναι αληθής. Η λογική έκφραση *Α*  and *B*  είναι αληθής μόνο όταν
# και η *Α* και η *Β* είναι αληθείς, σε κάθε άλλη περίπτωση είναι ψευδής. Η
# λογική έκφραση *Α* or *Β* είναι αληθής όταν η *Α* είναι αληθής ή η *Β* είναι
# αληθής, ή όταν και οι δύο είναι αληθείς.
# 
# Όταν χρησιμοποιούμε τον όρο **and** σημαίνει ότι και οι δύο προτάσεις πρέπει να είναι αληθείς για να αποδόσουν αληθές αποτέλεσμα.
# true.
# 
# Γενικά μπορούμε να συνοψίσουμε την χρήση του τελεστή **and** και την σύγκριση ανάμεσα σε τιμές boolean με βάση των παρακάτω πίνακα {cite}`Heisler2021`:
# 
# | Συνδυασμός με τον τελεστή and 	| Αποτέλεσμα 	|
# |---------------------------------	|-------------	|
# | True and True                   	| True        	|
# | True and False                  	| False       	|
# | False and True                  	| False       	|
# | False and False                 	| False       	|
# 
# Με την χρήση του όρου **or** αρκεί μία από τις δύο προτάσεις να είναι True για να αποδόσει αποτέλεσμα αληθές. 
# Αυτό φαίνεται πιο καλά στο παραπάνω πίνακα:
# 
# | Συνδυασμός με τον τελεστή or 	| Αποτέλεσμα 	|
# |---------------------------------	|-------------	|
# | True or True                   	| True        	|
# | True or False                  	| True       	|
# | False or True                  	| True       	|
# | False or False                 	| False       	|
# 
# 
# 
# Τέλος με την χρήση του όρου **not** αντιστρέφεται η τιμή True ή False μιας πρότασης.
# 
# 
# | Επίδραση του τελεστή not 	| Αποτέλεσμα 	|
# |---------------------------------	|-------------	|
# | not True                  	| False        	|
# | not False                  	| True       	|
# 
# 
# Φυσικά μπορούμε να συνδυάσουμε να συνδυάσμουμε τους όρους **and** **or** και **not** και να διαχωρίσουμε τις συγκρίσεις με παρανθέσεις ώστε να δημιουργήσουμε πιο σύνθετες εκφράσεις σύγκρισης:

# In[4]:


False or (False and True)


# In[5]:


True and (False or True)


# In[6]:


(not False) or True


# In[7]:


False or (not False)


# Σε μία λογική έκφραση μπορούμε να
# έχουμε και τελεστές σύγκρισης. Η Python έχει 6 τελεστές σύγκρισης:
# 
# Μικρότερο από ( < )
# Μικρότερο/ίσο από (<=)
# Μεγαλύτερο από (>)
# Μεγαλύτερο/ίσο από (>=)
# Ίσο με( == )
# Διαφορετικό από ( != )
# Αυτοί οι τελεστές συγκρίνουν δύο τιμές και επιστρέφουν μια τιμή τύπου boolean δηλαδή είτε *True* είτε *False*.
# 
# Οι λογικές εκφράσεις χρησιμοποιούν παρενθέσεις και κανόνες
# προτεραιότητας, για να καθορίσουν τη σειρά αποτίμησης των τμημάτων από τα
# οποία αποτελούνται. Οι εκφράσεις μέσα σε παρενθέσεις αποτιμώνται πρώτες. Η
# προτεραιότητα των τελεστών, από τη μεγαλύτερη στη μικρότερη, είναι οι εξής:
# 
# <, >, <=, >=, !=, ==, not, and, or.
# 
# 
# ```{warning} Προσοχή!
# Δεν πρέπει να συγχέεται ο τελεστής εκχώρησης τιμών σε μεταβλητή **=** με τον τελεστή ισότητας **==**.
# ```
# Μερικά παραδείγματα τελεστών σύγκρισης

# In[8]:


print(1 != 2)
print(1 != 1)


# In[9]:


a = 1
b = 2
print(a == b)
a = b
a==b
print(a!=b)


# In[10]:


1< 2 and 3 < 4 


# In[11]:


2< 1 and 4 < 3


# In[12]:


1< 2 and 4 < 3 


# In[13]:


2< 1 and 3 < 4 


# Τους τελεστές σύγκρισης μπορούμε να τους χρησιμοποιήσουμε και με συμβολοσειρές:

# In[14]:


"dog" == "cat"


# In[15]:


"dog" == "dog"


# In[16]:


"dog" != "cat"


# Για να είναι δύο συμβολοσειρές ίσες πρέπει να έχουν ακριβώς την ίδια τιμή. 
# Διαφοροποιήσεις ανάμεσα σε κεφαλαία ή μικρά ή η ύπαρξη κενών ανάμεσα σε δύο μεταβλητές συμβολοσειρών θα αποδόσει False σε μια έκφραση σύγκρισης ισότητας δηλαδή ότι οι δύο συμβολοσειρές δεν είναι ίσες.
# 
# Μπορούμε να συνδυάσουμε τους τελεστές σύγκρισης με λογικές τιμές boolean και τους λογικούς τελεστές **or**, **and** και **not**. 
# 
# Για παράδειγμα:

# In[17]:


True and not (1 != 1)


# In[18]:


("A" != "A") or not (2 >= 3)


# ## α. Η δομή της ακολουθίας εντολών
# 
# Οι εντολές σε ένα πρόγραμμα εκτελούνται σειριακά η μία μετά την άλλη
# ξεκινώντας από την πρώτη. Τελειώνει η εκτέλεση μίας εντολής και ακολου-
# θεί η εκτέλεση της επόμενης. Κάθε εντολή θα εκτελεστεί ακριβώς μία φορά,
# χωρίς δηλαδή να παραλειφθεί καμία από αυτές ή να επιστρέψουμε για να ξα-
# ναεκτελέσουμε κάποια.
# Παρακάτω δίνεται ένα χαρακτηριστικό παράδειγμα δομής ακολουθίας εντολών.

# In[19]:


A=1
B=5
C=A+B
print(C)


# Σε αυτό το παράδειγμα οι εντολές εκτελούνται στο σύνολό τους, διαδοχικά η μία μετά την άλλη.
# 
# 
# ## β. Η δομή της απόφασης 
# 
# Στη δομή της απόφασης έχουμε μία περισσότερο πολύπλοκη δομή, στην
# οποία ο έλεγχος του προγράμματος καλείται να επιλέξει ανάμεσα σε δύο ή και
# περισσότερες διαφορετικές διαδρομές ανάλογα με το αν ισχύει ή όχι κάποια ή
# κάποιες συνθήκες. Για την υλοποίηση της απόφασης, κάθε γλώσσα μπορεί να
# έχει μία ή περισσότερες δομές. Η πιο συνηθισμένη είναι η δομή **if**, ενώ υπάρχει
# συνήθως και μία δομή για πολλαπλή απόφαση. Η Python έχει την **if-elif-else** για
# να υλοποιήσει την απόφαση, αλλά δεν έχει δομή για την πολλαπλή απόφαση
# και χρησιμοποιεί την **if-elif-else** για τον σκοπό αυτόν {cite}`Manis2015`. 
# 
# Η εντολή **if** χρησιμοποείται για έλεγχο της ροής εκτέλεσης ενός
# προγράμματος. Ελέγχεται μία συνθήκη και ανάλογα με το αποτέλεσμα (Αληθής ή
# Ψευδής) εκτελείται ή δεν εκτελείται μία ή κάποια άλλη ομάδα (μπλοκ) εντολών {cite}`Aggelidakis2015`.
# Η εντολή if συντάσσεται ως εξής:
# 
# 
# ```
# if συνθήκη:
# 
#     μπλοκ εντολών 1 (true_block)
# 
# else:
#     μπλοκ εντολών  (false_block)
# 
# 
# ```
# 
# 
# Κατά την εκτέλεση του παρακάτω κώδικα η Python θα δοκιμάσει  την έκφραση (expression). Αν επιστρέψει True τότε θα εκτελέσει τις προτάσεις κώδικα που περιλαμβάνει η ενότητα true_block.
# Αν επιστρέψει όμως False θα εκτελέσει τις εντολές στην ενότητα false_block.
# Στην πιο απλή της μορφή η δομή της απόφασης μπορεί να παραλείπει το else τμήμα και το αντίστοιχο μπλοκ εντολών δηλ:
# 
# ```
# if συνθήκη:
# 
#     μπλοκ εντολών  (true_block)
# 
# ```
# 
# 
# Παρατηρήστε ότι η εντολή if μετά τον έλεγχο της συνθήκης κλείνει με : και στην συνέχεια ακολουθούν με εσοχή (indentation) οι εντολές/προτάσεις που θα εκτελεστούν εφόσον αληθεύει το αποτέλεσμα του ελέγχου.
# Από : ακολουθείται και η εντολή else. Το μπλοκ της εντολής ονομάζεται σώμα (body). Πρέπει να περιέχει υποχρεωτικά μια εντολή. Αν προσωρινά δεν θέλουμε να περιέχει κάποια εντολή μπορούμε να εισάγουμε την εντολή
# **pass**. Ιδιαίτερη σημασία πρέπει να δίνεται κατά την σύνταξη κατά την χρήση δηλαδή του σημείου : και την εσοχή των εντολών.
# Παρακάτων δίνεται ένα απλό παράδειγμα δομής απόφασης:

# In[20]:


weight = 100
if weight > 90:
    print("Είστε υπέρβαρος.Παρακαλώ αποφύγετε τον ανελκυστήρα.")
print("Ευχαριστούμε για την συνεργασία.")


# Παράδειγμα κώδικα if-else:

# In[21]:


temperature = 20
if temperature > 30:
    print('Φορέστε κοντομάνικα.')
else:
    print('Φορέστε μακρυμάνικα.')
print('Ευχαριστώ.')


# Για να προσθέσουμε περισσότερες επιλογές κατά τον έλεγχο συνθηκών χρησιμοποιούμε την σύνταξη if-elif-else:

# In[22]:


score=90
if score >= 90:
    letter = 'A'
elif score >= 80:
    letter = 'B'
elif score >= 70:
    letter = 'C'
elif score >= 60:
    letter = 'D'
else:
    letter = 'F'


# Οι συνθήκες if είναι δυνατόν να είναι αλυσιδωτές (εμφωλευμένες)
#  δηλαδή if πρόταση μέσα σε άλλη if πρόταση:

# In[23]:


num = 15
if num >= 0:
    if num == 0:
        print("Ο αριθμός δεν είναι ούτε αρνητικός ούτε θετικός")
    else:
        print("Ο αριθμός είναι θετικός")
else:
    print("Ο αριθμός είναι θετικός")


# ## γ. η δομή της επανάληψης
# 
# Η δομή της επανάληψης είναι μια μορφή κώδικα κατά την οποία περιλαμβάνει εντολές οι οποίες εκτελούνται επαναληπτικά για όσο τηρείται μια συνθήκη.
# Με αυτόν τον τρόπο αποφεύγεται η επανάληψη της συγγραφής του ίδιου κώδικα πολλές φορές.
# Στο παρακάτω τμήμα κώδικα είναι χαρακτηριστικό πως επαναλαμβάνεται ο ίδιος κώδικα πολλές φορές.

# In[24]:


print("Hello World")
print("Hello World")
print("Hello World")
print("Hello World")
print("Hello World")


# Αυτό όμως θα μπορούσε να αποφευχθεί με την χρήση μια δομής επανάληψης. Μια δομή επανάληψη ονομάζεται και βρόγχος (loop).
# Οι δομές επανάληψης διαχωρίζονται σε 3 κατηγορίες:
# - ο βρόγχος **while**, ο οποίος επαναλαμβάνει μια πρόταση ή μια σειρά προτάσεων όσο ισχύει μια συνθήκη. Κάθε φορά που επαναλαμβάνεται ένας κύκλος εκτέλεσης δοκιμάζεται αν ισχύει η συνθήκη αυτή.
# - ο βρόγχος **for**, κατά τον οποίο επαναλαμβάνεται μια σειρά προτάσεων για κάθε ένα στοιχείο μιας ακολουθίας δεδομένων (πχ λίστας, πλειάδας, λεξικού κτλ.). 
# - εμφωλευμένοι βρόγχοι, που ουσιαστικά πρόκειται για συνδυασμό βρόγχων while ή for. Έτσι μπορούμε να δομήσουμε ένα βρόγχο while μέσα σε έναν for, έναν for μέσα σε έναν while, έναν for μέσα σε έναν for και έναν while μέσα σε έναν while.
# 
# Παρακάτω δίνονται παραδείγματα για την κάθε κατηγορία.
# 
# 
# **Βρόγχος while**

# In[25]:


count = 0
while (count < 10):   
    count = count + 1
    print("Hello World")


# **Βρόγχος for**

# In[26]:


fruits = ["Μήλο", "Κεράσι", "Αχλάδι"]
for x in fruits:
  print(x)


# **εμφωλευμένοι βρόγχοι** (for μέσα σε for)

# In[27]:


for i in range(1, 11):
    # nested loop
    # to iterate from 1 to 10
    for j in range(1, 11):
        # print multiplication
        print(i * j, end=' ')


# Οι βρόγχοι for πρέπει να εκτελούν κάποια πρόταση. Σε διαφορετική περίπτωση αν θέλουμε να τους χρησιμοποιήσουμε χωρίς να κάνουν τίποτα (πχ για να συγγράψουμε αργότερα το περιεχόμενό τους)
# μπορούμε να χρησιμοποιήσουμε την πρόταση **pass**.

# In[28]:


for x in [0, 1, 2]:
  pass


# Μια χρήσιμη συνάρτηση που χρησιμοποιείται σε συνδυασμό με τους βρόγχους for είναι η συνάρτηση range().
# Η συνάρτηση range δημιουργεί μια ακολουθία αριθμών και προσφέρει σχετικές παραμέτρους για την έναρξη και λήξη και το βήμα της ακολουθίας δηλαδή range(start, stop,step_size).

# In[29]:


range(0, 10)


# Σε συνδυασμό με τον βρόγχο for μπορούμε να επαναλάβουμε μια σειρά προτάσεων κώδικα για μια ακολουθία αριθμών.

# In[30]:


genre = ['Φυσικά', 'Μαθηματικά', 'Χημεία']

# iterate over the list using index
for i in range(len(genre)):
    print("Διαβάζω ", genre[i])


# **εμφωλευμένοι βρόγχοι** (while μέσα σε for)

# In[31]:


names = ['Νίκος', 'Κώστας', 'Ελένη']
# outer loop
for name in names:
    # inner while loop
    count = 0
    while count < 5:
        print(name, end=' ')
        # increment counter
        count = count + 1
    print()


# **εμφωλευμένοι βρόγχοι** (while μέσα σε while)

# In[32]:


i = 1
while i <= 4 :
    j = 0
    while  j <= 3 :
        print(i*j, end=" ")
        j += 1
    print()
    i += 1


# ### Η πρόταση else μέσα σε βρόγχους
# 
# Όταν η συνθήκη βάσει της οποία ελέγχεται η εκτέλεση ενός βρόγχου while αποτυγχάνει (δεν είναι αληθής) τότε μπορούμε να εκτελέσουμε μια άλλη σειρά προτάσεων που ορίζεται από την ενότητα else.
# Για παράδειγμα:

# In[33]:


count=0
while(count<5):
    print(count)
    count +=1
else:
    print("count value reached %d" %(count))


# Αντίστοιχα σε έναν βρόγχο for μπορούμε να εκτελέσουμε μια ομάδα προτάσεων που ορίζεται από το else όταν έχει εξαντληθεί η προσπέλαση όλων των στοιχείων μιας ακολουθίας.
# Δείτε το παρακάτω παράδειγμα:

# In[34]:


for x in range(6):
  print(x)
else:
  print("Finally finished!")


# ### Οι προτάσεις break και continue 
# Οι προτάσεις break και continue χρησιμοποιούνται για το έλεγχο της ροής των επαναλήψεων και λειτουργούν με τον ίδιο τρόπο τόσο στους βρόγχους while όσο και στους βρόγχους for.
# 
# Η πρόταση break τερματίζει άμεσα την εκτέλεση του βρόγχου με βάση τον έλεγχο μιας συνθήκης και στην συνέχεια ακολουθεί η εκτέλεση της πρότασης που ακολουθεί τον βρόγχο.
# 
# Παράδειγμα με βρόγχο for:

# In[35]:


for num in range(1, 11):
    if num == 5:
        break
    else:
        print(num)

print("Τέλος")


# Παράδειγμα με βρόγχο while:

# In[36]:


n = 5
while n > 0:
    n -= 1
    if n == 2:
        break
    print(n)
print('Loop ended.')


# Αντίστοιχη είναι η λειτουργία της πρότασης continue.
# Ωστόσο σε αυτήν την περίπτωση ο βρόγχος δεν τερματίζεται εντελώς 
# αλλά σταματάει την τρέχουσα σειρά εντολών στο τρέχον σημείο του βρόγχου και συνεχίζει στο επόμενο στοιχείο της ακολουθίας και στον έλεγχο της αντίστοιχης συνθήκης.
